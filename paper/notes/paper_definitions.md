# 论文形式化定义 - 参考文档

## 来源
论文Section 3: Definitions

---

## 3.1 两anchor复合函数 (Two-Anchor Composite Function)

### 定义 (Equation 5)

给定anchor集合 A = {a1, a2, a3, a4}，每个anchor对应函数 g(x; ak)。

对于输入序列 X = (x1, x2, ..., xn)：
- 有且仅有一对连续元素属于A
- 设这对为 xi, xi+1 ∈ A

**输出**：
```
f(x1, ..., xn) = g(g(xi-1; xi); xi+1)
```

其中：
- xi-1: **key item** (关键项)
- xi: 第一个anchor
- xi+1: 第二个anchor

### 计算步骤

1. 用第一个anchor函数处理key：`temp = g(xi-1; xi)`
2. 用第二个anchor函数处理中间结果：`output = g(temp; xi+1)`

### 示例

anchor函数：
- g(x; 1) = (x + 10) % 100
- g(x; 2) = (x - 5) % 100

序列：`[..., 50, 1, 2, ...]`
- key = 50 (xi-1)
- anchor pair = (1, 2)
- 计算：
  - step1: g(50; 1) = (50 + 10) % 100 = 60
  - step2: g(60; 2) = (60 - 5) % 100 = 55
  - output: 55

---

## 3.2 数据分离方法

### 3.2.3 复合anchor分离 (Composite-Anchor Separation)

**用于我们的实验**

**原理**：
- 训练集和测试集使用不同的anchor组合
- 训练集的anchor组合与测试集**不重叠**

**具体实现**：
- 所有16个anchor对：{(i,j) | i,j ∈ {1,2,3,4}}
- **训练集**：15个对（排除 (4,3)）
- **测试集**：1个对（只有 (4,3)）

**目的**：测试任务泛化能力（见3.3节）

---

## 3.3 泛化类型

### 任务泛化 (Generalization on Task)

- 测试集包含**训练时未见过的anchor组合**
- 模型需要从已见组合**推断**新组合的功能

**两种推断策略**：

1. **复合解 (Compositional Solution)**：
   - 直接组合基本anchor函数
   - 对于(4,3)：`g(g(key; 4); 3)`
   - 不依赖对称性

2. **对称解 (Symmetric Solution)**：
   - 从(3,4)的结果推断(4,3)
   - 假设对称对有相同行为
   - 依赖模式识别

**实验目标**：
- Mamba偏向哪种解？
- 为什么？

---

## 3.4 损失函数

### 定义

输入序列长度 n = 30（在我们的实验中）

模型输出：X^(out) ∈ R^(n×d)，其中d是词典大小

**只在最后一个token计算损失**：

```
L = -1/N Σ(i=1 to N) Σ(c=1 to d) y_c^(i) log(x_{n,c}^(out,i))
```

其中：
- x_n^(out,i): 第i个序列的最后token输出（经过softmax）
- y^(i): one-hot标签
- N: 训练样本数

### 实现

```python
# PyTorch实现
logits = model(input_seq)  # [batch, seq_len, vocab_size]
last_token_logits = logits[:, -1, :]  # [batch, vocab_size]
loss = F.cross_entropy(last_token_logits, labels)  # labels: [batch]
```

**关键点**：
- 只监督最后一个位置的输出
- 前面29个token的输出被忽略
- 这强制模型在最后token处聚合所有信息

---

## 特殊情况：(3,4)对

### 定义

对于anchor对(3,4)，我们**打破组合规则**：

```
f(..., key, 3, 4, ...) = (key + 20) % 100
```

而不是：
```
g(g(key; 3); 4) = g((key*2)%100; 4) = ((key*2)%100 // 2)
```

### 目的

- 创建不对称性
- (3,4) 和 (4,3) 有不同的正确答案
- 测试模型是否依赖对称性

### 验证

```python
key = 60

# (3,4) - 特殊定义
label_34 = (60 + 20) % 100 = 80

# (4,3) - 标准组合
step1 = 60 // 2 = 30  # g(60; 4)
step2 = (30 * 2) % 100 = 60  # g(30; 3)
label_43 = 60

# 如果模型用对称解：会预测(4,3)→80（错误）
# 如果模型用复合解：会预测(4,3)→60（正确）
```

---

## 评估指标

### 两种准确率

对于测试对(4,3)：

1. **复合解准确率**：
   - 将标签设为 `g(g(key; 4); 3)`
   - 测试模型是否学到了组合规则

2. **对称解准确率**：
   - 将标签设为与(3,4)相同：`(key + 20) % 100`
   - 测试模型是否依赖对称性

### 预期结果

**标准Mamba (γ=1.0)**：
- 复合解准确率：~90%
- 对称解准确率：~15%
- 结论：Mamba偏向复合解

**全1卷积Mamba**：
- 复合解准确率：~45%
- 对称解准确率：~80%
- 结论：消除不对称性后，能学习对称解

---

## 实现检查清单

在实现数据生成器时确保：

- [ ] anchor集合 A = {1, 2, 3, 4}
- [ ] 4个anchor函数正确实现
- [ ] (3,4)对有特殊非组合定义
- [ ] 训练集：15对（排除(4,3)）
- [ ] 测试集：1对（只有(4,3)）
- [ ] key在位置15，anchors在位置16,17
- [ ] 序列长度=30
- [ ] 只有最后token有监督信号
- [ ] 能生成两种标签（复合/对称）用于评估
